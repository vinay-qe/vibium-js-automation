interface BiDiEvent {
    method: string;
    params: Record<string, unknown>;
}

type EventHandler = (event: BiDiEvent) => void;
declare class BiDiClient {
    private connection;
    private nextId;
    private pendingCommands;
    private eventHandler;
    private constructor();
    static connect(url: string): Promise<BiDiClient>;
    private handleResponse;
    private handleEvent;
    onEvent(handler: EventHandler): void;
    send<T = unknown>(method: string, params?: Record<string, unknown>): Promise<T>;
    close(): Promise<void>;
}

interface ClickerProcessOptions {
    port?: number;
    headless?: boolean;
    executablePath?: string;
}
declare class ClickerProcess {
    private process;
    private _port;
    private _stopped;
    private constructor();
    get port(): number;
    static start(options?: ClickerProcessOptions): Promise<ClickerProcess>;
    stop(): Promise<void>;
}

interface BoundingBox {
    x: number;
    y: number;
    width: number;
    height: number;
}
interface ElementInfo {
    tag: string;
    text: string;
    box: BoundingBox;
}
interface ActionOptions {
    /** Timeout in milliseconds for actionability checks. Default: 30000 */
    timeout?: number;
}
declare class Element {
    private client;
    private context;
    private selector;
    readonly info: ElementInfo;
    constructor(client: BiDiClient, context: string, selector: string, info: ElementInfo);
    /**
     * Click the element.
     * Waits for element to be visible, stable, receive events, and enabled.
     */
    click(options?: ActionOptions): Promise<void>;
    /**
     * Type text into the element.
     * Waits for element to be visible, stable, receive events, enabled, and editable.
     */
    type(text: string, options?: ActionOptions): Promise<void>;
    text(): Promise<string>;
    getAttribute(name: string): Promise<string | null>;
    boundingBox(): Promise<BoundingBox>;
    private getCenter;
}

interface FindOptions {
    /** Timeout in milliseconds to wait for element. Default: 30000 */
    timeout?: number;
}
declare class Vibe {
    private client;
    private process;
    private context;
    constructor(client: BiDiClient, process: ClickerProcess | null);
    private getContext;
    go(url: string): Promise<void>;
    screenshot(): Promise<Buffer>;
    /**
     * Execute JavaScript in the page context.
     */
    evaluate<T = unknown>(script: string): Promise<T>;
    /**
     * Find an element by CSS selector.
     * Waits for element to exist before returning.
     */
    find(selector: string, options?: FindOptions): Promise<Element>;
    quit(): Promise<void>;
}

interface LaunchOptions$1 {
    headless?: boolean;
    port?: number;
    executablePath?: string;
}
declare const browser: {
    launch(options?: LaunchOptions$1): Promise<Vibe>;
};

declare class SyncBridge {
    private worker;
    private signal;
    private commandId;
    private terminated;
    private constructor();
    static create(): SyncBridge;
    call<T = unknown>(method: string, args?: unknown[]): T;
    tryQuit(): void;
    terminate(): void;
}

declare class ElementSync {
    private bridge;
    private elementId;
    readonly info: ElementInfo;
    constructor(bridge: SyncBridge, elementId: number, info: ElementInfo);
    /**
     * Click the element.
     * Waits for element to be visible, stable, receive events, and enabled.
     */
    click(options?: ActionOptions): void;
    /**
     * Type text into the element.
     * Waits for element to be visible, stable, receive events, enabled, and editable.
     */
    type(text: string, options?: ActionOptions): void;
    text(): string;
    getAttribute(name: string): string | null;
    boundingBox(): BoundingBox;
}

declare class VibeSync {
    private bridge;
    constructor(bridge: SyncBridge);
    go(url: string): void;
    screenshot(): Buffer;
    /**
     * Execute JavaScript in the page context.
     */
    evaluate<T = unknown>(script: string): T;
    /**
     * Find an element by CSS selector.
     * Waits for element to exist before returning.
     */
    find(selector: string, options?: FindOptions): ElementSync;
    quit(): void;
}

interface LaunchOptions {
    headless?: boolean;
}
declare const browserSync: {
    launch(options?: LaunchOptions): VibeSync;
};

/**
 * Custom error types for the Vibium client library.
 */
/**
 * ConnectionError is thrown when connecting to the browser fails.
 */
declare class ConnectionError extends Error {
    url: string;
    cause?: Error | undefined;
    constructor(url: string, cause?: Error | undefined);
}
/**
 * TimeoutError is thrown when a wait operation times out.
 */
declare class TimeoutError extends Error {
    selector: string;
    timeout: number;
    reason?: string | undefined;
    constructor(selector: string, timeout: number, reason?: string | undefined);
}
/**
 * ElementNotFoundError is thrown when a selector matches no elements.
 */
declare class ElementNotFoundError extends Error {
    selector: string;
    constructor(selector: string);
}
/**
 * BrowserCrashedError is thrown when the browser process dies unexpectedly.
 */
declare class BrowserCrashedError extends Error {
    exitCode: number;
    output?: string | undefined;
    constructor(exitCode: number, output?: string | undefined);
}

export { type ActionOptions, type BoundingBox, BrowserCrashedError, ConnectionError, Element, type ElementInfo, ElementNotFoundError, ElementSync, type FindOptions, TimeoutError, Vibe, VibeSync, browser, browserSync };
