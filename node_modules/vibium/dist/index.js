"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var index_exports = {};
__export(index_exports, {
  BrowserCrashedError: () => BrowserCrashedError,
  ConnectionError: () => ConnectionError,
  Element: () => Element,
  ElementNotFoundError: () => ElementNotFoundError,
  ElementSync: () => ElementSync,
  TimeoutError: () => TimeoutError,
  Vibe: () => Vibe,
  VibeSync: () => VibeSync,
  browser: () => browser,
  browserSync: () => browserSync
});
module.exports = __toCommonJS(index_exports);

// src/clicker/platform.ts
var import_os = __toESM(require("os"));
function getPlatform() {
  const platform = import_os.default.platform();
  if (platform === "linux" || platform === "darwin" || platform === "win32") {
    return platform;
  }
  throw new Error(`Unsupported platform: ${platform}`);
}
function getArch() {
  const arch = import_os.default.arch();
  if (arch === "x64" || arch === "arm64") {
    return arch;
  }
  throw new Error(`Unsupported architecture: ${arch}`);
}

// src/clicker/binary.ts
var import_fs = __toESM(require("fs"));
var import_path = __toESM(require("path"));
function getClickerPath() {
  const envPath = process.env.CLICKER_PATH;
  if (envPath && import_fs.default.existsSync(envPath)) {
    return envPath;
  }
  const platform = getPlatform();
  const arch = getArch();
  const packageName = `@vibium/${platform}-${arch}`;
  const binaryName = platform === "win32" ? "clicker.exe" : "clicker";
  try {
    const packagePath = require.resolve(`${packageName}/package.json`);
    const packageDir = import_path.default.dirname(packagePath);
    const binaryPath = import_path.default.join(packageDir, "bin", binaryName);
    if (import_fs.default.existsSync(binaryPath)) {
      return binaryPath;
    }
  } catch {
  }
  const localPaths = [
    // From vibium/ root
    import_path.default.resolve(process.cwd(), "clicker", "bin", binaryName),
    // From clients/javascript/
    import_path.default.resolve(process.cwd(), "..", "..", "clicker", "bin", binaryName)
  ];
  for (const localPath of localPaths) {
    if (import_fs.default.existsSync(localPath)) {
      return localPath;
    }
  }
  throw new Error(
    `Could not find clicker binary. Set CLICKER_PATH environment variable or install ${packageName}`
  );
}

// src/clicker/process.ts
var import_child_process = require("child_process");

// src/utils/errors.ts
var ConnectionError = class extends Error {
  constructor(url, cause) {
    super(cause ? `Failed to connect to ${url}: ${cause.message}` : `Failed to connect to ${url}`);
    this.url = url;
    this.cause = cause;
    this.name = "ConnectionError";
  }
};
var TimeoutError = class extends Error {
  constructor(selector, timeout, reason) {
    const msg = reason ? `Timeout after ${timeout}ms waiting for '${selector}': ${reason}` : `Timeout after ${timeout}ms waiting for '${selector}'`;
    super(msg);
    this.selector = selector;
    this.timeout = timeout;
    this.reason = reason;
    this.name = "TimeoutError";
  }
};
var ElementNotFoundError = class extends Error {
  constructor(selector) {
    super(`Element not found: ${selector}`);
    this.selector = selector;
    this.name = "ElementNotFoundError";
  }
};
var BrowserCrashedError = class extends Error {
  constructor(exitCode, output) {
    const msg = output ? `Browser crashed with exit code ${exitCode}: ${output}` : `Browser crashed with exit code ${exitCode}`;
    super(msg);
    this.exitCode = exitCode;
    this.output = output;
    this.name = "BrowserCrashedError";
  }
};

// src/clicker/process.ts
var ClickerProcess = class _ClickerProcess {
  constructor(process2, port) {
    this._stopped = false;
    this.process = process2;
    this._port = port;
  }
  get port() {
    return this._port;
  }
  static async start(options = {}) {
    const binaryPath = options.executablePath || getClickerPath();
    const port = options.port || 0;
    const args = ["serve"];
    if (port > 0) {
      args.push("--port", port.toString());
    }
    if (options.headless === true) {
      args.push("--headless");
    }
    const proc = (0, import_child_process.spawn)(binaryPath, args, {
      stdio: ["ignore", "pipe", "pipe"]
    });
    const actualPort = await new Promise((resolve, reject) => {
      let output = "";
      let resolved = false;
      const timeout = setTimeout(() => {
        if (!resolved) {
          reject(new TimeoutError("clicker", 1e4, "waiting for clicker to start"));
        }
      }, 1e4);
      const handleData = (data) => {
        const text = data.toString();
        output += text;
        const match = output.match(/Server listening on ws:\/\/localhost:(\d+)/);
        if (match && !resolved) {
          resolved = true;
          clearTimeout(timeout);
          resolve(parseInt(match[1], 10));
        }
      };
      proc.stdout?.on("data", handleData);
      proc.stderr?.on("data", handleData);
      proc.on("error", (err) => {
        if (!resolved) {
          resolved = true;
          clearTimeout(timeout);
          reject(err);
        }
      });
      proc.on("exit", (code) => {
        if (!resolved) {
          resolved = true;
          clearTimeout(timeout);
          reject(new BrowserCrashedError(code ?? 1, output));
        }
      });
    });
    return new _ClickerProcess(proc, actualPort);
  }
  async stop() {
    if (this._stopped) {
      return;
    }
    this._stopped = true;
    return new Promise((resolve) => {
      this.process.on("exit", () => {
        resolve();
      });
      this.process.kill("SIGTERM");
      setTimeout(() => {
        if (!this.process.killed) {
          this.process.kill("SIGKILL");
        }
        resolve();
      }, 3e3);
    });
  }
};

// src/bidi/types.ts
function isResponse(msg) {
  return "id" in msg;
}
function isEvent(msg) {
  return !("id" in msg) && "method" in msg;
}

// src/bidi/connection.ts
var import_ws = __toESM(require("ws"));
var BiDiConnection = class _BiDiConnection {
  constructor(ws) {
    this.messageHandler = null;
    this._closed = false;
    this.ws = ws;
    this.closePromise = new Promise((resolve) => {
      ws.on("close", () => {
        this._closed = true;
        resolve();
      });
    });
    ws.on("message", (data) => {
      if (this.messageHandler) {
        try {
          const msg = JSON.parse(data.toString());
          this.messageHandler(msg);
        } catch (err) {
          console.error("Failed to parse BiDi message:", err);
        }
      }
    });
  }
  static connect(url) {
    return new Promise((resolve, reject) => {
      const ws = new import_ws.default(url);
      ws.on("open", () => {
        resolve(new _BiDiConnection(ws));
      });
      ws.on("error", (err) => {
        reject(new ConnectionError(url, err));
      });
    });
  }
  get closed() {
    return this._closed;
  }
  onMessage(handler) {
    this.messageHandler = handler;
  }
  send(message) {
    if (this._closed) {
      throw new Error("Connection closed");
    }
    this.ws.send(message);
  }
  async close() {
    if (this._closed) {
      return;
    }
    this.ws.close();
    await this.closePromise;
  }
};

// src/bidi/client.ts
var BiDiClient = class _BiDiClient {
  constructor(connection) {
    this.nextId = 1;
    this.pendingCommands = /* @__PURE__ */ new Map();
    this.eventHandler = null;
    this.connection = connection;
    connection.onMessage((msg) => {
      if (isResponse(msg)) {
        this.handleResponse(msg);
      } else if (isEvent(msg)) {
        this.handleEvent(msg);
      }
    });
  }
  static async connect(url) {
    const connection = await BiDiConnection.connect(url);
    return new _BiDiClient(connection);
  }
  handleResponse(response) {
    const pending = this.pendingCommands.get(response.id);
    if (!pending) {
      console.warn("Received response for unknown command:", response.id);
      return;
    }
    this.pendingCommands.delete(response.id);
    if (response.type === "error" && response.error) {
      pending.reject(new Error(`${response.error.error}: ${response.error.message}`));
    } else {
      pending.resolve(response.result);
    }
  }
  handleEvent(event) {
    if (this.eventHandler) {
      this.eventHandler(event);
    }
  }
  onEvent(handler) {
    this.eventHandler = handler;
  }
  send(method, params = {}) {
    return new Promise((resolve, reject) => {
      const id = this.nextId++;
      const command = { id, method, params };
      this.pendingCommands.set(id, {
        resolve,
        reject
      });
      try {
        this.connection.send(JSON.stringify(command));
      } catch (err) {
        this.pendingCommands.delete(id);
        reject(err);
      }
    });
  }
  async close() {
    for (const [id, pending] of this.pendingCommands) {
      pending.reject(new Error("Connection closed"));
      this.pendingCommands.delete(id);
    }
    await this.connection.close();
  }
};

// src/element.ts
var Element = class {
  constructor(client, context, selector, info2) {
    this.client = client;
    this.context = context;
    this.selector = selector;
    this.info = info2;
  }
  /**
   * Click the element.
   * Waits for element to be visible, stable, receive events, and enabled.
   */
  async click(options) {
    await this.client.send("vibium:click", {
      context: this.context,
      selector: this.selector,
      timeout: options?.timeout
    });
  }
  /**
   * Type text into the element.
   * Waits for element to be visible, stable, receive events, enabled, and editable.
   */
  async type(text, options) {
    await this.client.send("vibium:type", {
      context: this.context,
      selector: this.selector,
      text,
      timeout: options?.timeout
    });
  }
  async text() {
    const result = await this.client.send("script.callFunction", {
      functionDeclaration: `(selector) => {
        const el = document.querySelector(selector);
        return el ? (el.textContent || '').trim() : null;
      }`,
      target: { context: this.context },
      arguments: [{ type: "string", value: this.selector }],
      awaitPromise: false,
      resultOwnership: "root"
    });
    if (result.result.type === "null") {
      throw new ElementNotFoundError(this.selector);
    }
    return result.result.value;
  }
  async getAttribute(name) {
    const result = await this.client.send("script.callFunction", {
      functionDeclaration: `(selector, attrName) => {
        const el = document.querySelector(selector);
        return el ? el.getAttribute(attrName) : null;
      }`,
      target: { context: this.context },
      arguments: [
        { type: "string", value: this.selector },
        { type: "string", value: name }
      ],
      awaitPromise: false,
      resultOwnership: "root"
    });
    if (result.result.type === "null") {
      return null;
    }
    return result.result.value;
  }
  async boundingBox() {
    const result = await this.client.send("script.callFunction", {
      functionDeclaration: `(selector) => {
        const el = document.querySelector(selector);
        if (!el) return null;
        const rect = el.getBoundingClientRect();
        return JSON.stringify({
          x: rect.x,
          y: rect.y,
          width: rect.width,
          height: rect.height
        });
      }`,
      target: { context: this.context },
      arguments: [{ type: "string", value: this.selector }],
      awaitPromise: false,
      resultOwnership: "root"
    });
    if (result.result.type === "null") {
      throw new ElementNotFoundError(this.selector);
    }
    return JSON.parse(result.result.value);
  }
  getCenter() {
    return {
      x: this.info.box.x + this.info.box.width / 2,
      y: this.info.box.y + this.info.box.height / 2
    };
  }
};

// src/utils/debug.ts
var isDebugEnabled = process.env.VIBIUM_DEBUG === "1" || process.env.VIBIUM_DEBUG === "true";
function debug(message, data) {
  if (!isDebugEnabled) return;
  const timestamp = (/* @__PURE__ */ new Date()).toISOString();
  const logObj = {
    time: timestamp,
    level: "debug",
    msg: message,
    ...data
  };
  console.error(JSON.stringify(logObj));
}
function info(message, data) {
  if (!isDebugEnabled) return;
  const timestamp = (/* @__PURE__ */ new Date()).toISOString();
  const logObj = {
    time: timestamp,
    level: "info",
    msg: message,
    ...data
  };
  console.error(JSON.stringify(logObj));
}

// src/vibe.ts
var Vibe = class {
  constructor(client, process2) {
    this.context = null;
    this.client = client;
    this.process = process2;
  }
  async getContext() {
    if (this.context) {
      return this.context;
    }
    const tree = await this.client.send("browsingContext.getTree", {});
    if (!tree.contexts || tree.contexts.length === 0) {
      throw new Error("No browsing context available");
    }
    this.context = tree.contexts[0].context;
    return this.context;
  }
  async go(url) {
    debug("navigating", { url });
    const context = await this.getContext();
    await this.client.send("browsingContext.navigate", {
      context,
      url,
      wait: "complete"
    });
    debug("navigation complete", { url });
  }
  async screenshot() {
    const context = await this.getContext();
    const result = await this.client.send("browsingContext.captureScreenshot", {
      context
    });
    return Buffer.from(result.data, "base64");
  }
  /**
   * Execute JavaScript in the page context.
   */
  async evaluate(script) {
    const context = await this.getContext();
    const result = await this.client.send("script.callFunction", {
      functionDeclaration: `() => { ${script} }`,
      target: { context },
      arguments: [],
      awaitPromise: true,
      resultOwnership: "root"
    });
    return result.result.value;
  }
  /**
   * Find an element by CSS selector.
   * Waits for element to exist before returning.
   */
  async find(selector, options) {
    debug("finding element", { selector, timeout: options?.timeout });
    const context = await this.getContext();
    const result = await this.client.send("vibium:find", {
      context,
      selector,
      timeout: options?.timeout
    });
    const info2 = {
      tag: result.tag,
      text: result.text,
      box: result.box
    };
    debug("element found", { selector, tag: result.tag });
    return new Element(this.client, context, selector, info2);
  }
  async quit() {
    await this.client.close();
    if (this.process) {
      await this.process.stop();
    }
  }
};

// src/browser.ts
var browser = {
  async launch(options = {}) {
    const { headless = false, port, executablePath } = options;
    debug("launching browser", { headless, port, executablePath });
    const process2 = await ClickerProcess.start({
      headless,
      port,
      executablePath
    });
    debug("clicker started", { port: process2.port });
    const client = await BiDiClient.connect(`ws://localhost:${process2.port}`);
    info("browser launched", { port: process2.port });
    return new Vibe(client, process2);
  }
};

// src/sync/bridge.ts
var import_worker_threads = require("worker_threads");
var path2 = __toESM(require("path"));
var activeBridges = /* @__PURE__ */ new Set();
function cleanup() {
  for (const bridge of activeBridges) {
    try {
      bridge.tryQuit();
    } catch {
    }
  }
  activeBridges.clear();
}
var handlersRegistered = false;
function registerCleanupHandlers() {
  if (handlersRegistered) return;
  handlersRegistered = true;
  process.on("exit", cleanup);
  process.on("SIGINT", () => {
    cleanup();
    process.exit(130);
  });
  process.on("SIGTERM", () => {
    cleanup();
    process.exit(143);
  });
}
var SyncBridge = class _SyncBridge {
  constructor(worker, signal) {
    this.commandId = 0;
    this.terminated = false;
    this.worker = worker;
    this.signal = signal;
  }
  static create() {
    registerCleanupHandlers();
    const signal = new Int32Array(new SharedArrayBuffer(4));
    const workerPath = path2.join(__dirname, "worker.js");
    const worker = new import_worker_threads.Worker(workerPath, {
      workerData: { signal }
    });
    const bridge = new _SyncBridge(worker, signal);
    activeBridges.add(bridge);
    return bridge;
  }
  call(method, args = []) {
    const cmd = { id: this.commandId++, method, args };
    const { port1, port2 } = new import_worker_threads.MessageChannel();
    Atomics.store(this.signal, 0, 0);
    this.worker.postMessage({ cmd, port: port2 }, [port2]);
    Atomics.wait(this.signal, 0, 0);
    const message = (0, import_worker_threads.receiveMessageOnPort)(port1);
    port1.close();
    if (!message) {
      throw new Error("No response from worker");
    }
    const response = message.message;
    if (response.error) {
      throw new Error(response.error);
    }
    return response.result;
  }
  tryQuit() {
    if (this.terminated) return;
    try {
      const cmd = { id: this.commandId++, method: "quit", args: [] };
      const { port1, port2 } = new import_worker_threads.MessageChannel();
      Atomics.store(this.signal, 0, 0);
      this.worker.postMessage({ cmd, port: port2 }, [port2]);
      const result = Atomics.wait(this.signal, 0, 0, 5e3);
      port1.close();
      if (result === "timed-out") {
        this.terminate();
      } else {
        this.terminated = true;
        activeBridges.delete(this);
      }
    } catch {
      this.terminate();
    }
  }
  terminate() {
    if (this.terminated) return;
    this.terminated = true;
    activeBridges.delete(this);
    this.worker.terminate();
  }
};

// src/sync/element.ts
var ElementSync = class {
  constructor(bridge, elementId, info2) {
    this.bridge = bridge;
    this.elementId = elementId;
    this.info = info2;
  }
  /**
   * Click the element.
   * Waits for element to be visible, stable, receive events, and enabled.
   */
  click(options) {
    this.bridge.call("element.click", [this.elementId, options]);
  }
  /**
   * Type text into the element.
   * Waits for element to be visible, stable, receive events, enabled, and editable.
   */
  type(text, options) {
    this.bridge.call("element.type", [this.elementId, text, options]);
  }
  text() {
    const result = this.bridge.call("element.text", [this.elementId]);
    return result.text;
  }
  getAttribute(name) {
    const result = this.bridge.call("element.getAttribute", [this.elementId, name]);
    return result.value;
  }
  boundingBox() {
    const result = this.bridge.call("element.boundingBox", [this.elementId]);
    return result.box;
  }
};

// src/sync/vibe.ts
var VibeSync = class {
  constructor(bridge) {
    this.bridge = bridge;
  }
  go(url) {
    this.bridge.call("go", [url]);
  }
  screenshot() {
    const result = this.bridge.call("screenshot");
    return Buffer.from(result.data, "base64");
  }
  /**
   * Execute JavaScript in the page context.
   */
  evaluate(script) {
    const result = this.bridge.call("evaluate", [script]);
    return result.result;
  }
  /**
   * Find an element by CSS selector.
   * Waits for element to exist before returning.
   */
  find(selector, options) {
    const result = this.bridge.call("find", [selector, options]);
    return new ElementSync(this.bridge, result.elementId, result.info);
  }
  quit() {
    this.bridge.call("quit");
    this.bridge.terminate();
  }
};

// src/sync/browser.ts
var browserSync = {
  launch(options = {}) {
    const bridge = SyncBridge.create();
    bridge.call("launch", [options]);
    return new VibeSync(bridge);
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  BrowserCrashedError,
  ConnectionError,
  Element,
  ElementNotFoundError,
  ElementSync,
  TimeoutError,
  Vibe,
  VibeSync,
  browser,
  browserSync
});
